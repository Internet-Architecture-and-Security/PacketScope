// Code generated by bpf2go; DO NOT EDIT.
//go:build mips || mips64 || ppc64 || s390x

package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type connTrackerConnInfo struct {
	Packets   uint64
	Bytes     uint64
	IpId      uint32
	_         [4]byte
	StartTime uint64
	LastSeen  uint64
	TcpFlags  uint8
	_         [3]byte
	Seq       uint32
	AckSeq    uint32
	Window    uint16
	_         [2]byte
}

type connTrackerConnKey struct {
	SrcIp    uint32
	DstIp    uint32
	SrcPort  uint16
	DstPort  uint16
	Protocol uint8
	Pad      [3]uint8
}

type connTrackerFilterRule struct {
	SrcIp         uint32
	DstIp         uint32
	SrcPort       uint16
	DstPort       uint16
	Protocol      uint8
	Action        uint8
	Enabled       uint8
	RuleType      uint8
	IcmpType      uint8
	IcmpCode      uint8
	TcpFlags      uint8
	TcpFlagsMask  uint8
	InnerSrcIp    uint32
	InnerDstIp    uint32
	InnerProtocol uint8
	Pad           [3]uint8
}

type connTrackerIcmpInfo struct {
	Packets       uint64
	Bytes         uint64
	IpId          uint32
	_             [4]byte
	LastSeen      uint64
	Type          uint8
	Code          uint8
	_             [2]byte
	InnerSrcIp    uint32
	InnerDstIp    uint32
	InnerProtocol uint8
	_             [1]byte
	InnerSrcPort  uint16
	InnerDstPort  uint16
	_             [6]byte
}

type connTrackerIcmpKey struct {
	SrcIp uint32
	DstIp uint32
	Type  uint8
	Code  uint8
	_     [2]byte
}

type connTrackerPerfStats struct {
	IcmpTypeCounts   [16]uint64
	IcmpCodeCounts   [256]uint64
	TcpRetrans       uint64
	TcpDuplicateAck  uint64
	TcpOutOfOrder    uint64
	TcpZeroWindow    uint64
	TcpSmallWindow   uint64
	TotalPackets     uint64
	TotalBytes       uint64
	DroppedPackets   uint64
	MalformedPackets uint64
}

// loadConnTracker returns the embedded CollectionSpec for connTracker.
func loadConnTracker() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_ConnTrackerBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load connTracker: %w", err)
	}

	return spec, err
}

// loadConnTrackerObjects loads connTracker and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*connTrackerObjects
//	*connTrackerPrograms
//	*connTrackerMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadConnTrackerObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadConnTracker()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// connTrackerSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type connTrackerSpecs struct {
	connTrackerProgramSpecs
	connTrackerMapSpecs
	connTrackerVariableSpecs
}

// connTrackerProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type connTrackerProgramSpecs struct {
	ConnTracker *ebpf.ProgramSpec `ebpf:"conn_tracker"`
}

// connTrackerMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type connTrackerMapSpecs struct {
	ConnMap      *ebpf.MapSpec `ebpf:"conn_map"`
	FilterMap    *ebpf.MapSpec `ebpf:"filter_map"`
	IcmpMap      *ebpf.MapSpec `ebpf:"icmp_map"`
	PerfStatsMap *ebpf.MapSpec `ebpf:"perf_stats_map"`
}

// connTrackerVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type connTrackerVariableSpecs struct {
}

// connTrackerObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadConnTrackerObjects or ebpf.CollectionSpec.LoadAndAssign.
type connTrackerObjects struct {
	connTrackerPrograms
	connTrackerMaps
	connTrackerVariables
}

func (o *connTrackerObjects) Close() error {
	return _ConnTrackerClose(
		&o.connTrackerPrograms,
		&o.connTrackerMaps,
	)
}

// connTrackerMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadConnTrackerObjects or ebpf.CollectionSpec.LoadAndAssign.
type connTrackerMaps struct {
	ConnMap      *ebpf.Map `ebpf:"conn_map"`
	FilterMap    *ebpf.Map `ebpf:"filter_map"`
	IcmpMap      *ebpf.Map `ebpf:"icmp_map"`
	PerfStatsMap *ebpf.Map `ebpf:"perf_stats_map"`
}

func (m *connTrackerMaps) Close() error {
	return _ConnTrackerClose(
		m.ConnMap,
		m.FilterMap,
		m.IcmpMap,
		m.PerfStatsMap,
	)
}

// connTrackerVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadConnTrackerObjects or ebpf.CollectionSpec.LoadAndAssign.
type connTrackerVariables struct {
}

// connTrackerPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadConnTrackerObjects or ebpf.CollectionSpec.LoadAndAssign.
type connTrackerPrograms struct {
	ConnTracker *ebpf.Program `ebpf:"conn_tracker"`
}

func (p *connTrackerPrograms) Close() error {
	return _ConnTrackerClose(
		p.ConnTracker,
	)
}

func _ConnTrackerClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed conntracker_bpfeb.o
var _ConnTrackerBytes []byte
